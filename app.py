import streamlit as st
from openai import OpenAI
import os
from dotenv import load_dotenv
import time
import json
from datetime import datetime
from textblob import TextBlob
import sqlite3
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go

# Load environment variables
load_dotenv()

# Set up OpenAI client
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

# Define mood colors and scores for anonymous posts
MOOD_COLORS = {
    "éå¸¸å¼€å¿ƒ ğŸ˜Š": {"color": "#FFD700", "score": 100},  # Gold
    "å¿ƒæƒ…ä¸é”™ ğŸ™‚": {"color": "#98FB98", "score": 75},   # Pale Green
    "ä¸€èˆ¬èˆ¬ ğŸ˜": {"color": "#87CEEB", "score": 50},     # Sky Blue
    "æœ‰ç‚¹ä½è½ ğŸ˜”": {"color": "#DDA0DD", "score": 25},   # Plum
    "å¾ˆéš¾è¿‡ ğŸ˜¢": {"color": "#CD5C5C", "score": 0}      # Indian Red
}

# Define situation type mapping
SITUATION_TYPES = {
    "å­¦ä¹ ç›¸å…³ï¼ˆå¦‚å›¾ä¹¦é¦†ä½¿ç”¨ã€ä¸æ•™æˆæ²Ÿé€šç­‰ï¼‰": "å­¦ä¹ ç›¸å…³",
    "æ–‡åŒ–é€‚åº”ï¼ˆå¦‚ç†è§£ç¾å›½äººçš„ç¤¾äº¤ä¹ æƒ¯ï¼‰": "æ–‡åŒ–é€‚åº”",
    "ç”Ÿæ´»é—®é¢˜ï¼ˆå¦‚ä½å®¿ã€äº¤é€šã€é¥®é£Ÿç­‰ï¼‰": "ç”Ÿæ´»é—®é¢˜",
    "å…¶ä»–": "å…¶ä»–"
}

# Database setup
def init_db():
    conn = sqlite3.connect('cultural_navigator.db')
    c = conn.cursor()
    
    # Create anonymous posts table with new fields
    c.execute('''CREATE TABLE IF NOT EXISTS anonymous_posts
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  content TEXT NOT NULL,
                  category TEXT,
                  mood TEXT,
                  mood_color TEXT,
                  post_date DATE,
                  sentiment_score REAL,
                  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)''')
    
    c.execute('''CREATE TABLE IF NOT EXISTS emotional_states
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  user_session TEXT,
                  emotion TEXT,
                  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP)''')
    conn.commit()
    conn.close()

# Initialize database
init_db()

def analyze_emotion(text):
    """Analyze emotion in text using TextBlob"""
    analysis = TextBlob(text)
    return {
        'polarity': analysis.sentiment.polarity,
        'subjectivity': analysis.sentiment.subjectivity
    }

def save_anonymous_post(content, category, mood=None, mood_color=None, post_date=None):
    """Save anonymous post to database with mood and date"""
    sentiment = analyze_emotion(content)
    conn = sqlite3.connect('cultural_navigator.db')
    c = conn.cursor()
    
    # Get mood score if mood is provided
    mood_score = MOOD_COLORS[mood]["score"] if mood else 50
    
    c.execute('''INSERT INTO anonymous_posts 
                 (content, category, mood, mood_color, post_date, sentiment_score)
                 VALUES (?, ?, ?, ?, ?, ?)''', 
              (content, category, mood, MOOD_COLORS[mood]["color"] if mood else None, post_date, mood_score))
    conn.commit()
    conn.close()

def get_anonymous_posts():
    """Retrieve anonymous posts from database"""
    conn = sqlite3.connect('cultural_navigator.db')
    posts = pd.read_sql_query(
        "SELECT * FROM anonymous_posts ORDER BY timestamp DESC", 
        conn,
        parse_dates=['post_date']
    )
    conn.close()
    return posts

def get_chat_messages(message_type):
    """Get chat messages from session state"""
    if message_type not in st.session_state:
        st.session_state[message_type] = []
    return st.session_state[message_type]

def generate_response(prompt, query_type, context=None):
    """Generate response using OpenAI API"""
    try:
        messages = []
        
        # Add system message based on query type
        if query_type == "cultural_advice":
            system_message = """ä½ æ˜¯ä¸€ä½ç»éªŒä¸°å¯Œçš„æ–‡åŒ–é¡¾é—®ï¼Œä¸“é—¨å¸®åŠ©å›½é™…å­¦ç”Ÿé€‚åº”æ–°çš„æ–‡åŒ–ç¯å¢ƒã€‚
            ä½ éœ€è¦ï¼š
            1. æä¾›å…·ä½“ã€å®ç”¨çš„å»ºè®®
            2. è§£é‡Šæ–‡åŒ–å·®å¼‚èƒŒåçš„åŸå› 
            3. åˆ†äº«ç›¸å…³çš„æ–‡åŒ–ä¹ ä¿—å’Œç¤¼ä»ª
            4. ç»™å‡ºå®é™…çš„ä¾‹å­å’Œæƒ…å¢ƒ
            è¯·åŸºäºç”¨æˆ·çš„å…·ä½“æƒ…å†µæä¾›ä¸ªæ€§åŒ–çš„å»ºè®®ã€‚"""
            
            # Add context to the conversation
            if context:
                messages.append({"role": "system", "content": system_message})
                messages.append({"role": "user", "content": f"ç”¨æˆ·èƒŒæ™¯ä¿¡æ¯ï¼š{context}"})
        
        elif query_type == "emotion_support":
            emotion_data = analyze_emotion(prompt)
            system_message = f"""ä½ æ˜¯ä¸€ä½å¯Œæœ‰åŒç†å¿ƒçš„å¿ƒç†æ”¯æŒé¡¾é—®ã€‚
            ç”¨æˆ·å½“å‰çš„æƒ…æ„ŸçŠ¶æ€æ˜¾ç¤ºæƒ…æ„Ÿææ€§ä¸º{emotion_data['polarity']}ã€‚
            è¯·ï¼š
            1. è¡¨è¾¾ç†è§£å’Œè®¤åŒ
            2. æä¾›æƒ…æ„Ÿæ”¯æŒ
            3. ç»™å‡ºå®ç”¨çš„å»ºè®®
            4. é¼“åŠ±ç§¯æçš„æ€åº¦
            æ³¨æ„ä½¿ç”¨æ¸©å’Œã€æ”¯æŒæ€§çš„è¯­è¨€ã€‚"""
            messages.append({"role": "system", "content": system_message})
        
        elif query_type == "anonymous_sharing":
            system_message = """ä½ æ˜¯ä¸€ä½ç†è§£å’Œæ”¯æŒçš„å€¾å¬è€…ã€‚
            å¯¹äºåŒ¿ååˆ†äº«ï¼š
            1. è¡¨ç¤ºç†è§£å’ŒåŒç†
            2. åˆ†äº«ç±»ä¼¼ç»å†ï¼ˆå¦‚æœé€‚ç”¨ï¼‰
            3. æä¾›å»ºè®¾æ€§çš„å»ºè®®
            4. é¼“åŠ±ç»§ç»­åˆ†äº«
            è¯·ä¿æŒæ–‡åŒ–æ•æ„Ÿæ€§ã€‚"""
            messages.append({"role": "system", "content": system_message})

        # Add the user's prompt
        messages.append({"role": "user", "content": prompt})

        # Get chat history
        chat_history = get_chat_messages(f"{query_type}_messages")
        
        # Add recent chat history (last 5 exchanges) to maintain context
        if chat_history:
            recent_history = chat_history[-10:]  # Get last 5 exchanges (10 messages)
            for msg in recent_history:
                messages.append({"role": msg["role"], "content": msg["content"]})

        # Generate response using chat completion
        response = client.chat.completions.create(
            model="gpt-4",
            messages=messages,
            temperature=0.7,
            max_tokens=1000
        )

        return response.choices[0].message.content

    except Exception as e:
        return f"å‘ç”Ÿé”™è¯¯ï¼š{str(e)}"

def create_mood_calendar(posts):
    """Create a calendar visualization of moods"""
    if len(posts) == 0:
        return None
    
    # Create calendar data
    calendar_data = posts.copy()
    calendar_data['post_date'] = pd.to_datetime(calendar_data['post_date'])
    
    # Get the current month's data
    current_month = calendar_data['post_date'].dt.to_period('M').iloc[0]
    month_data = calendar_data[calendar_data['post_date'].dt.to_period('M') == current_month]
    
    # Create calendar grid using plotly
    fig = go.Figure()
    
    # Get the number of days in the month
    year = current_month.year
    month = current_month.month
    num_days = pd.Period(current_month).days_in_month
    
    # Create a date range for the entire month
    date_range = pd.date_range(start=f"{year}-{month:02d}-01", 
                             end=f"{year}-{month:02d}-{num_days}")
    
    # Calculate the week number for each day
    weeks = [d.isocalendar()[1] for d in date_range]
    min_week = min(weeks)
    
    # Create grid of all days
    for date in date_range:
        day = date.day
        week = date.isocalendar()[1] - min_week
        
        # Check if we have mood data for this day
        day_data = month_data[month_data['post_date'].dt.date == date.date()]
        
        if not day_data.empty:
            # Use the mood color from the data
            color = day_data.iloc[0]['mood_color']
            hover_text = f"æ—¥æœŸ: {date.strftime('%Y-%m-%d')}<br>å¿ƒæƒ…: {day_data.iloc[0]['mood']}<br>åˆ†ç±»: {day_data.iloc[0]['category']}<br>å†…å®¹: {day_data.iloc[0]['content'][:50]}..."
        else:
            # Use a neutral color for days without data
            color = '#EAEAEA'
            hover_text = f"æ—¥æœŸ: {date.strftime('%Y-%m-%d')}<br>æ²¡æœ‰è®°å½•"
        
        # Add square for the day
        fig.add_trace(go.Scatter(
            x=[week],
            y=[day],
            mode='markers',
            marker=dict(
                color=color,
                size=30,
                symbol='square',
                line=dict(color='#FFFFFF', width=1)
            ),
            text=hover_text,
            hoverinfo='text',
            showlegend=False
        ))
    
    # Update layout
    fig.update_layout(
        title=f"å¿ƒæƒ…æ—¥å† - {year}å¹´{month}æœˆ",
        xaxis_title="å‘¨",
        yaxis_title="æ—¥",
        height=500,
        margin=dict(l=40, r=40, t=60, b=40),
        plot_bgcolor='white',
        xaxis=dict(
            tickmode='array',
            ticktext=['ç¬¬1å‘¨', 'ç¬¬2å‘¨', 'ç¬¬3å‘¨', 'ç¬¬4å‘¨', 'ç¬¬5å‘¨', 'ç¬¬6å‘¨'],
            tickvals=list(range(6)),
            gridcolor='#EAEAEA',
            showgrid=True
        ),
        yaxis=dict(
            tickmode='array',
            ticktext=[str(i) for i in range(1, 32)],
            tickvals=list(range(1, 32)),
            gridcolor='#EAEAEA',
            showgrid=True,
            autorange='reversed'  # Reverse y-axis to show days from top to bottom
        )
    )
    
    return fig

def create_mood_tracking_graph(posts):
    """Create a line graph showing mood trends over time"""
    if len(posts) == 0:
        return None
    
    # Create mood tracking data
    mood_data = posts.copy()
    mood_data['post_date'] = pd.to_datetime(mood_data['post_date'])
    
    # Sort by date
    mood_data = mood_data.sort_values('post_date')
    
    # Create line graph
    fig = go.Figure()
    
    fig.add_trace(go.Scatter(
        x=mood_data['post_date'],
        y=mood_data['sentiment_score'],
        mode='lines+markers',
        line=dict(color='#6495ED', width=2),
        marker=dict(
            color=mood_data['mood_color'],
            size=12,
            line=dict(color='white', width=1)
        ),
        text=mood_data['mood'],
        hovertemplate="æ—¥æœŸ: %{x}<br>å¿ƒæƒ…: %{text}<br>å¿ƒæƒ…æŒ‡æ•°: %{y}<extra></extra>"
    ))
    
    # Update layout
    fig.update_layout(
        title="å¿ƒæƒ…å˜åŒ–è¶‹åŠ¿",
        xaxis_title="æ—¥æœŸ",
        yaxis_title="å¿ƒæƒ…æŒ‡æ•°",
        yaxis=dict(
            range=[0, 100],
            tickmode='array',
            ticktext=['å¾ˆéš¾è¿‡', 'æœ‰ç‚¹ä½è½', 'ä¸€èˆ¬', 'å¿ƒæƒ…ä¸é”™', 'éå¸¸å¼€å¿ƒ'],
            tickvals=[0, 25, 50, 75, 100]
        ),
        height=300,
        margin=dict(l=40, r=40, t=60, b=40),
        plot_bgcolor='white',
        xaxis=dict(gridcolor='#EAEAEA'),
        yaxis_gridcolor='#EAEAEA'
    )
    
    return fig

def main():
    st.set_page_config(page_title="æ–‡åŒ–å¯¼èˆªåŠ©æ‰‹", layout="wide")

    # Add custom CSS
    st.markdown("""
        <style>
        div.stButton > button {
            float: right;
        }
        .mood-tracker {
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 10px;
            margin: 20px 0;
        }
        </style>
    """, unsafe_allow_html=True)

    # Initialize session states
    if "cultural_messages" not in st.session_state:
        st.session_state.cultural_messages = []
    if "emotional_messages" not in st.session_state:
        st.session_state.emotional_messages = []
    if "current_status" not in st.session_state:
        st.session_state.current_status = ""
    if "situation_type" not in st.session_state:
        st.session_state.situation_type = "å­¦ä¹ ç›¸å…³"
    if "emotional_state" not in st.session_state:
        st.session_state.emotional_state = "ä¸€èˆ¬"
    if "other_situation_enabled" not in st.session_state:
        st.session_state.other_situation_enabled = False
    if "other_situation_text" not in st.session_state:
        st.session_state.other_situation_text = ""

    # Sidebar navigation
    st.sidebar.title("åŠŸèƒ½å¯¼èˆª")
    page = st.sidebar.radio(
        "é€‰æ‹©åŠŸèƒ½ï¼š",
        ["æ–‡åŒ–é€‚åº”åŠ æ²¹ç«™â›½ï¸", "æš–å¿ƒèŠèŠå¤©ğŸ’•", "åŒ¿åæ ‘æ´ğŸŒ³", "æˆ‘çš„æ•…äº‹"]
    )

    if page == "æ–‡åŒ–é€‚åº”åŠ æ²¹ç«™â›½ï¸":
        st.title("æ–‡åŒ–é€‚åº”åŠ æ²¹ç«™â›½ï¸")
        
        # Welcome message and explanation
        st.markdown("""
        ### äº²çˆ±çš„æœ‹å‹ï¼ğŸŒŸ 
        
        æ˜¯ä¸æ˜¯æ„Ÿè§‰æ–°ç¯å¢ƒæœ‰ç‚¹è®©äººæ‰‹è¶³æ— æªï¼Ÿåˆ«æ‹…å¿ƒï¼Œæˆ‘ä»¬éƒ½ç»å†è¿‡è¿™ä¸ªé˜¶æ®µã€‚æ¥æ¥æ¥ï¼Œè®©æˆ‘ä»¬ä¸€èµ·èŠèŠä½ é‡åˆ°çš„å…·ä½“é—®é¢˜å§ï¼
        
        è¯·å¡«å†™ä¸‹é¢çš„ä¿¡æ¯ï¼Œå¸®åŠ©æˆ‘ä»¬æ›´å¥½åœ°äº†è§£ä½ çš„æƒ…å†µï¼Œæä¾›æ›´æœ‰é’ˆå¯¹æ€§çš„å»ºè®®ã€‚
        """)

        # User information inputs with optimized updates
        current_status = st.text_area(
            "å½“å‰çŠ¶æ€æè¿°",
            value=st.session_state.current_status,
            placeholder="è¯·ç®€è¦æè¿°ä½ ç›®å‰çš„æƒ…å†µï¼Œæ¯”å¦‚ï¼šåˆšæ¥ç¾å›½ä¸€ä¸ªæœˆï¼Œæ­£åœ¨é€‚åº”æ–°çš„å­¦ä¹ ç¯å¢ƒ...",
            key="status_input"
        )
        if current_status != st.session_state.current_status:
            st.session_state.current_status = current_status
        
        # Create columns for situation type selection
        col1, col2 = st.columns([0.7, 0.3])
        
        with col1:
            st.selectbox(
                "æƒ…æ™¯ç±»å‹",
                list(SITUATION_TYPES.keys()),
                key="situation_input"
            )
        
        with col2:
            other_situation = st.text_input(
                "å…¶ä»–æƒ…æ™¯",
                value=st.session_state.other_situation_text,
                placeholder="è¯·æè¿°æ‚¨çš„å…·ä½“æƒ…æ™¯",
                disabled=not st.session_state.other_situation_enabled,
                key="other_situation_text"
            )
        
        emotional_state = st.select_slider(
            "å½“å‰æƒ…ç»ªçŠ¶æ€",
            options=["éå¸¸å›°æ‰°", "æœ‰ç‚¹ç„¦è™‘", "ä¸€èˆ¬", "è¿˜å¥½", "å¾ˆä¹è§‚"],
            value=st.session_state.emotional_state
        )
        if emotional_state != st.session_state.emotional_state:
            st.session_state.emotional_state = emotional_state

        # Create a container for chat messages
        chat_container = st.container()

        # Display cultural consultation messages
        for idx, message in enumerate(st.session_state.cultural_messages):
            col1, col2 = chat_container.columns([0.9, 0.1])
            with col1:
                with st.chat_message(message["role"]):
                    st.markdown(message["content"])
            with col2:
                if st.button("åˆ é™¤", key=f"delete_cultural_{idx}"):
                    del st.session_state.cultural_messages[idx]
                    st.experimental_rerun()

        # Question input
        user_input = st.chat_input("è¯·è¯¦ç»†æè¿°ä½ æœ€å…³å¿ƒçš„å…·ä½“é—®é¢˜æˆ–ç–‘è™‘...")

        if user_input:
            # Prepare context
            context = f"""
            æƒ…æ™¯ç±»å‹ï¼š{st.session_state.situation_type}
            å½“å‰çŠ¶æ€ï¼š{st.session_state.current_status}
            æƒ…ç»ªçŠ¶æ€ï¼š{st.session_state.emotional_state}
            """
            
            with st.spinner('æ­£åœ¨è®¤çœŸå€¾å¬ä½ çš„å¿ƒäº‹...'):
                # Generate response
                response = generate_response(user_input, "cultural_advice", context)
                
                # Save both messages after response is generated
                st.session_state.cultural_messages.append({"role": "user", "content": user_input})
                st.session_state.cultural_messages.append({"role": "assistant", "content": response})
                st.experimental_rerun()

    elif page == "æš–å¿ƒèŠèŠå¤©ğŸ’•":
        st.title("æš–å¿ƒèŠèŠå¤©ğŸ’•")
        
        # Welcome message and explanation for emotional support
        st.markdown("""
        ### æ¸©æš–çš„å€¾å¬ç©ºé—´ ğŸ’
        
        æ¯ä¸ªäººéƒ½ä¼šæœ‰æƒ…ç»ªèµ·ä¼çš„æ—¶å€™ï¼Œè¿™é‡Œæ˜¯ä½ çš„å®‰å…¨æ¸¯æ¹¾ã€‚
        æ— è®ºæ˜¯å­¦ä¸šå‹åŠ›ã€æ€ä¹¡ä¹‹æƒ…ï¼Œè¿˜æ˜¯å¯¹æœªæ¥çš„è¿·èŒ«ï¼Œéƒ½å¯ä»¥åœ¨è¿™é‡Œå€¾è¯‰ã€‚
        
        æˆ‘ä»¬ä¼šè®¤çœŸå€¾å¬ä½ çš„æ¯ä¸€ä¸ªæ„Ÿå—ï¼Œç»™äºˆæ¸©æš–çš„æ”¯æŒå’Œå»ºè®®ã€‚
        è¯·éšæ„åˆ†äº«ä½ çš„å¿ƒæƒ…ï¼Œè®©æˆ‘ä»¬ä¸€èµ·é¢å¯¹ã€‚
        """)
        
        # Create a container for chat messages
        chat_container = st.container()

        # Display emotional support messages
        for idx, message in enumerate(st.session_state.emotional_messages):
            col1, col2 = chat_container.columns([0.9, 0.1])
            with col1:
                with st.chat_message(message["role"]):
                    st.markdown(message["content"])
            with col2:
                if st.button("åˆ é™¤", key=f"delete_emotional_{idx}"):
                    del st.session_state.emotional_messages[idx]
                    st.experimental_rerun()
        
        user_input = st.chat_input("åˆ†äº«æ‚¨çš„æ„Ÿå—...")
        
        if user_input:
            with st.spinner('æ­£åœ¨è®¤çœŸå€¾å¬ä½ çš„å¿ƒäº‹...'):
                # Generate response
                response = generate_response(user_input, "emotion_support")
                
                # Save both messages after response is generated
                st.session_state.emotional_messages.append({"role": "user", "content": user_input})
                st.session_state.emotional_messages.append({"role": "assistant", "content": response})
                st.experimental_rerun()

    elif page == "åŒ¿åæ ‘æ´ğŸŒ³":
        st.title("åŒ¿åæ ‘æ´ğŸŒ³")
        
        st.markdown("""
        ### åŒ¿ååˆ†äº«ç©ºé—´ ğŸŒ³
        
        è¿™é‡Œæ˜¯ä½ çš„ç§˜å¯†èŠ±å›­ï¼Œå¯ä»¥è‡ªç”±åœ°åˆ†äº«ä»»ä½•æƒ³æ³•å’Œç»å†ã€‚è®°å½•ä½ çš„å¿ƒæƒ…ï¼Œè¿½è¸ªä½ çš„æƒ…ç»ªå˜åŒ–ã€‚
        
        - å®Œå…¨åŒ¿åï¼šæ‰€æœ‰åˆ†äº«éƒ½æ˜¯åŒ¿åçš„ï¼Œè¯·æ”¾å¿ƒè¡¨è¾¾
        - å¿ƒæƒ…è®°å½•ï¼šé€‰æ‹©ä»£è¡¨ä½ å½“å‰å¿ƒæƒ…çš„é¢œè‰²
        - å¯è§†åŒ–è¿½è¸ªï¼šé€šè¿‡æ—¥å†å’Œå›¾è¡¨ç›´è§‚åœ°çœ‹åˆ°ä½ çš„æƒ…ç»ªå˜åŒ–
        """)
        
        tab1, tab2, tab3 = st.tabs(["å‘å¸ƒæ–°å¸–", "æŸ¥çœ‹åˆ†äº«", "å¿ƒæƒ…è¿½è¸ª"])
        
        with tab1:
            # Post creation form
            post_category = st.selectbox(
                "é€‰æ‹©åˆ†ç±»ï¼š",
                ["å­¦ä¸šå‹åŠ›", "æ–‡åŒ–é€‚åº”", "äººé™…å…³ç³»", "å…¶ä»–"]
            )
            
            # Mood selection
            selected_mood = st.select_slider(
                "å½“å‰å¿ƒæƒ…ï¼š",
                options=list(MOOD_COLORS.keys()),
                value="ä¸€èˆ¬èˆ¬ ğŸ˜"
            )
            
            # Show selected color
            st.markdown(f"""
                <div style="width: 30px; height: 30px; background-color: {MOOD_COLORS[selected_mood]['color']}; 
                border-radius: 5px; margin: 10px 0;"></div>
            """, unsafe_allow_html=True)
            
            # Date selection
            post_date = st.date_input(
                "é€‰æ‹©æ—¥æœŸï¼š",
                value=datetime.now()
            )
            
            # Content input
            post_content = st.text_area("åˆ†äº«æ‚¨çš„æ•…äº‹...")
            
            if st.button("å‘å¸ƒ"):
                if post_content:
                    with st.spinner('æ­£åœ¨å‘å¸ƒä¸­...'):
                        save_anonymous_post(
                            post_content, 
                            post_category,
                            selected_mood,
                            MOOD_COLORS[selected_mood]['color'],
                            post_date
                        )
                    st.success("å‘å¸ƒæˆåŠŸï¼")
                else:
                    st.warning("è¯·è¾“å…¥å†…å®¹åå†å‘å¸ƒ")
        
        with tab2:
            # Get all posts
            posts = get_anonymous_posts()
            
            if not posts.empty:
                # Display posts
                st.markdown("### å†å²åˆ†äº«")
                for _, post in posts.iterrows():
                    with st.expander(f"{post['category']} - {post['timestamp'][:16]}"):
                        # Show mood indicator if mood is available
                        if post['mood'] and post['mood_color']:
                            st.markdown(f"""
                                <div style="display: flex; align-items: center; margin-bottom: 10px;">
                                    <div style="width: 20px; height: 20px; background-color: {post['mood_color']}; 
                                    border-radius: 50%; margin-right: 10px;"></div>
                                    <span>{post['mood']}</span>
                                </div>
                            """, unsafe_allow_html=True)
                        
                        st.write(post['content'])
                        if st.button("æä¾›æ”¯æŒ", key=f"support_{post['id']}"):
                            with st.spinner('æ­£åœ¨ç”Ÿæˆå›åº”...'):
                                response = generate_response(post['content'], "anonymous_sharing")
                                st.write("AIæ”¯æŒå›åº”ï¼š", response)
            else:
                st.info("è¿˜æ²¡æœ‰ä»»ä½•åˆ†äº«ï¼Œæ¥åšç¬¬ä¸€ä¸ªåˆ†äº«çš„äººå§ï¼")
        
        with tab3:
            # Get all posts for mood tracking
            posts = get_anonymous_posts()
            
            if not posts.empty:
                st.markdown("""
                    <div class="mood-tracker">
                        <h3>å¿ƒæƒ…æ—¥å† ğŸ“…</h3>
                        <p>åœ¨è¿™é‡Œï¼Œä½ å¯ä»¥çœ‹åˆ°æ¯ä¸€å¤©çš„å¿ƒæƒ…å˜åŒ–ã€‚æ–¹å—çš„é¢œè‰²ä»£è¡¨é‚£ä¸€å¤©çš„å¿ƒæƒ…ï¼Œ
                        æ‚¬åœåœ¨æ–¹å—ä¸Šå¯ä»¥æŸ¥çœ‹è¯¦ç»†ä¿¡æ¯ã€‚</p>
                    </div>
                """, unsafe_allow_html=True)
                
                # Display calendar
                calendar_fig = create_mood_calendar(posts)
                if calendar_fig:
                    st.plotly_chart(calendar_fig, use_container_width=True)
                
                # Display mood tracking graph
                st.markdown("""
                    <div class="mood-tracker">
                        <h3>å¿ƒæƒ…è¶‹åŠ¿ ğŸ“ˆ</h3>
                        <p>è¿™æ¡æ›²çº¿å±•ç¤ºäº†ä½ çš„æƒ…ç»ªå˜åŒ–è¶‹åŠ¿ã€‚ç‚¹çš„é¢œè‰²ä»£è¡¨å½“å¤©çš„å¿ƒæƒ…ï¼Œ
                        æ›²çº¿çš„é«˜ä½è¡¨ç¤ºå¿ƒæƒ…çš„èµ·ä¼ã€‚</p>
                    </div>
                """, unsafe_allow_html=True)
                
                mood_graph = create_mood_tracking_graph(posts)
                if mood_graph:
                    st.plotly_chart(mood_graph, use_container_width=True)
            else:
                st.info("è¿˜æ²¡æœ‰ä»»ä½•å¿ƒæƒ…è®°å½•ï¼Œå‘å¸ƒä¸€ä¸ªå¸¦æœ‰å¿ƒæƒ…çš„åˆ†äº«æ¥å¼€å§‹è¿½è¸ªå§ï¼")

    elif page == "æˆ‘çš„æ•…äº‹":
        st.title("æˆ‘çš„æ•…äº‹")
        
        # Explanation for history page
        st.markdown("""
        ### ä½ çš„æˆé•¿è½¨è¿¹ ğŸ“
        
        è¿™é‡Œè®°å½•äº†ä½ ä¹‹å‰çš„æ‰€æœ‰å¯¹è¯å’Œäº¤æµã€‚
        å›é¡¾è¿‡å»çš„å¯¹è¯å¯ä»¥å¸®åŠ©ä½ çœ‹åˆ°è‡ªå·±çš„è¿›æ­¥å’Œæˆé•¿ã€‚
        """)
        
        tab1, tab2 = st.tabs(["æ–‡åŒ–é€‚åº”è®°å½•", "æƒ…æ„Ÿäº¤æµè®°å½•"])
        
        with tab1:
            cultural_container = st.container()
            for idx, message in enumerate(st.session_state.cultural_messages):
                col1, col2 = cultural_container.columns([0.9, 0.1])
                with col1:
                    with st.chat_message(message["role"]):
                        st.markdown(message["content"])
                with col2:
                    if st.button("åˆ é™¤", key=f"delete_cultural_history_{idx}"):
                        del st.session_state.cultural_messages[idx]
                        st.experimental_rerun()
            
        with tab2:
            emotional_container = st.container()
            for idx, message in enumerate(st.session_state.emotional_messages):
                col1, col2 = emotional_container.columns([0.9, 0.1])
                with col1:
                    with st.chat_message(message["role"]):
                        st.markdown(message["content"])
                with col2:
                    if st.button("åˆ é™¤", key=f"delete_emotional_history_{idx}"):
                        del st.session_state.emotional_messages[idx]
                        st.experimental_rerun()

    # Clear chat buttons in sidebar
    if st.sidebar.button("æ¸…é™¤æ–‡åŒ–é€‚åº”è®°å½•"):
        st.session_state.cultural_messages = []
        st.experimental_rerun()
        
    if st.sidebar.button("æ¸…é™¤æƒ…æ„Ÿäº¤æµè®°å½•"):
        st.session_state.emotional_messages = []
        st.experimental_rerun()

if __name__ == "__main__":
    main()
